package com.webapp.dqsys.mngr.service;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.tomcat.util.http.fileupload.servlet.ServletFileUpload;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.JSONValue;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.webapp.dqsys.mngr.domain.BaseFile;
import com.webapp.dqsys.mngr.mapper.DataStandardMapper;
import com.webapp.dqsys.util.CSVReader;
import com.webapp.dqsys.util.FileUploadUtil;
import com.webapp.dqsys.util.SangsAbstractService;

@Service
public class DataStandardService extends SangsAbstractService {

	protected Logger logger = LoggerFactory.getLogger(getClass());

//	@Resource(name = "oracleSqlSessionTemplate")
//	private SqlSessionTemplate oracleSqlSession;
//
//	@Resource(name = "msSqlSessionTemplate")
//	private SqlSessionTemplate msSqlSession;
//
//	@Resource(name = "mySqlSessionTemplate")
//	private SqlSessionTemplate mySqlSession;
//
//	@Resource(name = "mariaSqlSessionTemplate")
//	private SqlSessionTemplate mariaSqlSession;

	@Autowired
	private DataStandardMapper dataStandardMapper;

	@Value("${file.csv.dataDir}")
	private String csvDir;

	/**
	 * @param params
	 * @param res
	 * @return
	 * @throws Exception
	 * @throws IOException
	 */
	public void selectDataStandardManageList(Map<String, String> params, HttpServletResponse res)
			throws Exception, IOException {
		res.setContentType("text/html; charset=utf-8");
		PrintWriter out = res.getWriter();
		Map<String, Object> resultMap = new HashMap<String, Object>();
		ObjectMapper mapper = new ObjectMapper(); // parser
		String json = null;
		List<?> dataList = null;
		int totalCnt = 0;
		try {
			// 페이징 처리 설정
			super.pagingSet(params);

			if (params.get("tabType") != null && "word".equals(params.get("tabType"))) {
				// 표준 용어
				totalCnt = dataStandardMapper.selectWordListTotalCnt(params);
				dataList = dataStandardMapper.selectWordList(params);
			} else {
				// 도메인
				totalCnt = dataStandardMapper.selectDomainListTotalCnt(params);
				dataList = dataStandardMapper.selectDomainList(params);
			}
			resultMap.put("totalCnt", totalCnt);
			resultMap.put("dataList", dataList);
			resultMap.put("tabType", params.get("tabType"));
			json = mapper.writeValueAsString(resultMap);
		} catch (Exception e) {
			logger.error("[표준화 항목 관리 조회 오류]");
			logger.debug("error : " + e.getMessage());
			e.printStackTrace();
		} finally {
			out.print(json);
			out.flush();
			out.close();
		}
	}

	/**
	 * @param params
	 * @param req
	 * @param res
	 * @throws Exception
	 */
	public void saveDomainInfo(Map<String, String> params, HttpServletRequest req, HttpServletResponse res)
			throws Exception {

		res.setContentType("text/html; charset=utf-8");
		PrintWriter out = res.getWriter();
		String json = null;
		boolean result = false;
		Map<String, Object> resultMap = new HashMap<String, Object>();
		ObjectMapper mapper = new ObjectMapper(); // parser

		try {
			JSONArray arrItems = (JSONArray) JSONValue.parse(params.get("insertList"));

			HashMap<String, String> param = new HashMap<String, String>();

			for (Object o : arrItems) {
				JSONObject item = (JSONObject) o;

				param.put("domainCl", item.get("domainCl").toString());
				param.put("domainNm", item.get("domainNm").toString());
				param.put("domainTy", item.get("domainTy").toString());
				param.put("domainLt", item.get("domainLt").toString());
				param.put("domainRm", item.get("domainRm").toString());

				// Domain INSERT
				int insCnt = dataStandardMapper.insertDomainInfo(param);

				if (insCnt > 0) {
					result = true;
				}
			}

		} catch (Exception e) {
			logger.error("[도메인 저장 오류]");
			logger.debug("error : " + e.getMessage());
			e.printStackTrace();
		} finally {
			resultMap.put("result", result);
			json = mapper.writeValueAsString(resultMap);

			out.print(json);
			out.flush();
			out.close();
		}
	}

	/**
	 * @param params
	 * @param req
	 * @param res
	 * @throws Exception
	 */
	public void saveDomainCsv(Map<String, String> params, HttpServletRequest req, HttpServletResponse res)
			throws Exception {
		res.setContentType("text/html; charset=utf-8");
		PrintWriter out = res.getWriter();
		String json = null;
		boolean result = false;
		Map<String, Object> resultMap = new HashMap<String, Object>();
		ObjectMapper mapper = new ObjectMapper(); // parser
		File csvFile = null;
		FileInputStream fiStream = null;
		InputStreamReader isReader = null;
		CSVReader csvReader = null;

		try {
			// 임시저장 폴더에 파일 생성
			String attFileOutputPath = csvDir + "/";
			List<BaseFile> fileList = null;

			if (ServletFileUpload.isMultipartContent(req)) {
				fileList = FileUploadUtil.uploadFiles(req, attFileOutputPath);
			}

			// 임시저장에 등록된 파일 읽어들여 도메인 정보 저장
			if (fileList != null && fileList.size() > 0) {
				BaseFile vo = fileList.get(0);
				String attFileOutputFullPath = attFileOutputPath + vo.getPhysicalName();

				csvFile = new File(attFileOutputFullPath);

				if (csvFile.exists()) {
					char tempChar[] = ",".toCharArray();
					char separator = tempChar[0];
					fiStream = new FileInputStream(csvFile);
					isReader = new InputStreamReader(fiStream, "euc-kr");
					csvReader = new CSVReader(isReader, separator);
					String[] nextLine = null;

					int lowIndex = 0;
					int colIndex = 0;
					String[] colKeyArr = { "domainCl", "domainNm", "domainTy", "domainLt", "domainRm" };
					while ((nextLine = csvReader.readNext()) != null) {
						if (lowIndex > 0) {
							colIndex = 0;
							HashMap<String, String> param = new HashMap<String, String>();
							for (String str : nextLine) {
								if (str != null && !"".equals(str.trim())) {
									param.put(colKeyArr[colIndex], str);
								}
								++colIndex;
							}

							// 필수값 체크
							if (param.get("domainCl") != null && param.get("domainNm") != null
									&& param.get("domainTy") != null) {
								// 도메인 정보 저장
								int insCnt = dataStandardMapper.insertDomainInfo(param);
								if (insCnt > 0) {
									result = true;
								}
							}
						}
						++lowIndex;
					}
				}
			}
		} catch (Exception e) {
			result = false;
			logger.error("[도메인 CSV 저장 오류]");
			logger.debug("error : " + e.getMessage());
			e.printStackTrace();
		} finally {
			if (csvReader != null) {
				try {
					csvReader.close();
				} catch (IOException e) {
					logger.error("[CSVReader]");
					logger.debug("error : " + e.getMessage());
				}
			}
			if (isReader != null) {
				try {
					isReader.close();
				} catch (IOException e) {
					logger.error("[InputStreamReader]");
					logger.debug("error : " + e.getMessage());
				}
			}
			if (fiStream != null) {
				try {
					fiStream.close();
				} catch (IOException e) {
					logger.error("[FileInputStream]");
					logger.debug("error : " + e.getMessage());
				}
			}
			if (csvFile.exists()) {
				// 임시저장 폴더에 업로드된 파일 삭제
				csvFile.delete();
			}

			resultMap.put("result", result);
			json = mapper.writeValueAsString(resultMap);

			out.print(json);
			out.flush();
			out.close();
		}
	}

	/**
	 * @param params
	 * @param req
	 * @param res
	 * @throws Exception
	 */
	public void saveWordInfo(Map<String, String> params, HttpServletRequest req, HttpServletResponse res)
			throws Exception {

		res.setContentType("text/html; charset=utf-8");
		PrintWriter out = res.getWriter();
		String json = null;
		boolean result = false;
		Map<String, Object> resultMap = new HashMap<String, Object>();
		ObjectMapper mapper = new ObjectMapper(); // parser

		try {
			JSONArray arrItems = (JSONArray) JSONValue.parse(params.get("insertList"));

			HashMap<String, String> param = new HashMap<String, String>();

			for (Object o : arrItems) {
				JSONObject item = (JSONObject) o;

				param.put("wordNm", item.get("wordNm").toString());
				param.put("wordEngNm", item.get("wordEngNm").toString());
				param.put("wordEngAb", item.get("wordEngAb").toString());
				param.put("wordCl", item.get("wordCl").toString());
				param.put("wordRm", item.get("wordRm").toString());

				// Domain INSERT
				int insCnt = dataStandardMapper.insertWordInfo(param);

				if (insCnt > 0) {
					result = true;
				}
			}

		} catch (Exception e) {
			logger.error("[표준 용어 저장 오류]");
			logger.debug("error : " + e.getMessage());
			e.printStackTrace();
		} finally {
			resultMap.put("result", result);
			json = mapper.writeValueAsString(resultMap);

			out.print(json);
			out.flush();
			out.close();
		}
	}

	/**
	 * @param params
	 * @param req
	 * @param res
	 * @throws Exception
	 */
	public void saveWordCsv(Map<String, String> params, HttpServletRequest req, HttpServletResponse res)
			throws Exception {
		res.setContentType("text/html; charset=utf-8");
		PrintWriter out = res.getWriter();
		String json = null;
		boolean result = false;
		Map<String, Object> resultMap = new HashMap<String, Object>();
		ObjectMapper mapper = new ObjectMapper(); // parser
		File csvFile = null;
		FileInputStream fiStream = null;
		InputStreamReader isReader = null;
		CSVReader csvReader = null;

		try {
			// 임시저장 폴더에 파일 생성
			String attFileOutputPath = csvDir + "/";
			List<BaseFile> fileList = null;

			if (ServletFileUpload.isMultipartContent(req)) {
				fileList = FileUploadUtil.uploadFiles(req, attFileOutputPath);
			}

			// 임시저장에 등록된 파일 읽어들여 표준용어 정보 저장
			if (fileList != null && fileList.size() > 0) {
				BaseFile vo = fileList.get(0);
				String attFileOutputFullPath = attFileOutputPath + vo.getPhysicalName();

				csvFile = new File(attFileOutputFullPath);

				if (csvFile.exists()) {
					char tempChar[] = ",".toCharArray();
					char separator = tempChar[0];
					fiStream = new FileInputStream(csvFile);
					isReader = new InputStreamReader(fiStream, "euc-kr");
					csvReader = new CSVReader(isReader, separator);
					String[] nextLine = null;

					int lowIndex = 0;
					int colIndex = 0;
					String[] colKeyArr = { "wordNm", "wordEngNm", "wordEngAb", "wordCl", "wordRm" };
					while ((nextLine = csvReader.readNext()) != null) {
						if (lowIndex > 0) {
							colIndex = 0;
							HashMap<String, String> param = new HashMap<String, String>();
							for (String str : nextLine) {
								if (str != null && !"".equals(str.trim())) {
									if (colIndex == 3) {
										if ("표준어".equals(str)) {
											str = "0";
										} else if ("동의어".equals(str)) {
											str = "1";
										} else {
											str = null;
										}

										if (str != null) {
											param.put(colKeyArr[colIndex], str);
										}
									} else {
										param.put(colKeyArr[colIndex], str);
									}
								}
								++colIndex;
							}

							// 필수값 체크
							if (param.get("wordNm") != null && param.get("wordCl") != null) {
								// 표준 용어 정보 저장
								int insCnt = dataStandardMapper.insertWordInfo(param);
								if (insCnt > 0) {
									result = true;
								}
							}
						}
						++lowIndex;
					}
				}
			}
		} catch (Exception e) {
			result = false;
			logger.error("[표준 용어 CSV 저장 오류]");
			logger.debug("error : " + e.getMessage());
			e.printStackTrace();
		} finally {
			if (csvReader != null) {
				try {
					csvReader.close();
				} catch (IOException e) {
					logger.error("[CSVReader]");
					logger.debug("error : " + e.getMessage());
				}
			}
			if (isReader != null) {
				try {
					isReader.close();
				} catch (IOException e) {
					logger.error("[InputStreamReader]");
					logger.debug("error : " + e.getMessage());
				}
			}
			if (fiStream != null) {
				try {
					fiStream.close();
				} catch (IOException e) {
					logger.error("[FileInputStream]");
					logger.debug("error : " + e.getMessage());
				}
			}
			if (csvFile.exists()) {
				// 임시저장 폴더에 업로드된 파일 삭제
				csvFile.delete();
			}

			resultMap.put("result", result);
			json = mapper.writeValueAsString(resultMap);

			out.print(json);
			out.flush();
			out.close();
		}
	}
}
